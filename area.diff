diff --git a/adm/daemons/buildingd.c b/adm/daemons/buildingd.c
new file mode 100644
index 00000000..e0e2ad90
--- /dev/null
+++ b/adm/daemons/buildingd.c
@@ -0,0 +1,55 @@
+/* buildingd.c 建築物精靈
+   write by -Acme- 2009.03.27
+*/
+
+void create() { seteuid(getuid()); }
+
+string getRoomCode() {
+    string code;
+
+////////////////////////
+// start ROOM CODE
+////////////////////////
+    code = @ROOM_CODE
+// created by BUILDING_D
+
+inherit BUILD;
+
+ROOM_CODE;
+////////////////////////
+// edit ROOM CODE
+////////////////////////
+
+    return code;
+}
+
+string getAreaCode(int x, int y) {
+    string code;
+
+////////////////////////
+// start AREA CODE
+////////////////////////
+    code = @AREA_CODE
+// created by BUILDING_D
+
+inherit AREA_BUILD;
+
+void create()
+{
+    set("name", "空地");
+
+AREA_CODE;
+
+    code += "    set(\"x_axis_size\", " + x + ");\n";
+    code += "    set(\"y_axis_size\", " + y + ");\n";
+    code += @AREA_CODE
+
+    setup();
+}
+AREA_CODE;
+////////////////////////
+// edit AREA CODE
+////////////////////////
+
+    return code;
+}
diff --git a/adm/single/simul_efun/area.c b/adm/single/simul_efun/area.c
new file mode 100644
index 00000000..33a7198c
--- /dev/null
+++ b/adm/single/simul_efun/area.c
@@ -0,0 +1,173 @@
+/* area.c write by -Acme- */
+
+#pragma optimize
+
+// 比較二個物件是否處在相同的區域座標中
+int area_environment(object ob1, object ob2)
+{
+    if (environment(ob1) != environment(ob2))
+        return 0;
+    else
+    {
+        mapping info1, info2;
+        if (!(info1 = ob1->query("area_info")))
+            return 0;
+        if (!(info2 = ob2->query("area_info")))
+            return 0;
+        if (info1["x_axis"] != info2["x_axis"] || info1["y_axis"] != info2["y_axis"])
+            return 0;
+    }
+    return 1;
+}
+
+// 將who移到與me同一格的位置
+int move_side(object who, object me)
+{
+    int env_area = 0, x, y;
+    object area;
+    mapping who_info;
+
+    if (!objectp(who) || !objectp(me))
+        return 0;
+    if (!environment(me))
+        return 0;
+    if (!environment(me)->is_area())
+        return 0;
+
+    if (environment(who) && environment(who)->is_area())
+    {
+        who_info = who->query("area_info");
+        env_area = 1;
+    }
+
+    // 已經在同一個位置了
+    if (environment(me) == environment(who) &&
+        me->query("area_info/x_axis") == who->query("area_info/x_axis") &&
+        me->query("area_info/y_axis") == who->query("area_info/y_axis"))
+        return 1;
+
+    area = environment(me);
+    x = me->query("area_info/x_axis");
+    y = me->query("area_info/y_axis");
+
+    // 如果who移到area中失敗
+    if (!area->move_in(x, y, who))
+    {
+        return 0;
+    }
+
+    who->set("area_info/x_axis", x);
+    who->set("area_info/y_axis", y);
+
+    // 成功移入area, move() 會自動從舊area裡移出
+    if (who->move(area))
+    {
+        who->set("area_info/x_axis_old", x);
+        who->set("area_info/y_axis_old", y);
+        return 1;
+    }
+    else
+    {
+        // 將先前移到新的area再做移出
+        area->move_out(x, y, who);
+        if (env_area)
+        {
+            // 設回先前的 x, y
+            who->set("area_info/x_axis", who_info["x_axis_old"]);
+            who->set("area_info/y_axis", who_info["y_axis_old"]);
+            if (!environment(who)->move_in(who_info["x_axis_old"], who_info["y_axis_old"]))
+            {
+                tell_object(who, "因為某種原因，你的角色在區域移動時產生了錯誤...\n");
+                destruct(who);
+                return 0;
+            }
+        }
+    }
+}
+
+int area_move(object area, object who, int x, int y)
+{
+    mapping info;
+    int env_area = 0;
+
+    if (!objectp(who) || !objectp(area))
+        return 0;
+
+    if (environment(who) && environment(who)->is_area())
+    {
+        info = who->query("area_info");
+        env_area = 1;
+    }
+
+    // 已經在同一個位置了
+    if (area == environment(who) &&
+        x == who->query("area_info/x_axis") &&
+        y == who->query("area_info/y_axis"))
+        return 1;
+
+    // 如果who move_in到新的area中失敗
+    if (!area->move_in(x, y, who))
+        return 0;
+
+    who->set("area_info/x_axis", x);
+    who->set("area_info/y_axis", y);
+    // 成功移入area, move() 會自動從area裡移出
+    if (who->move(area))
+    {
+        who->set("area_info/x_axis_old", x);
+        who->set("area_info/y_axis_old", y);
+        return 1;
+    }
+    // 移入area失敗，如果原本是在area環境中，必須再移入一次
+    else
+    {
+        // 將先前移到新的area再做移出
+        area->move_out(x, y, who);
+        if (env_area)
+        {
+            // 設回先前的 x, y
+            who->set("area_info/x_axis", info["x_axis_old"]);
+            who->set("area_info/y_axis", info["y_axis_old"]);
+            if (!environment(who)->move_in(info["x_axis_old"], info["y_axis_old"]))
+            {
+                tell_object(who, "因為某種原因，你的角色在區域移動時產生了錯誤...\n");
+                destruct(who);
+                return 0;
+            }
+        }
+    }
+    return 0;
+}
+
+// 覆寫mudos present函式
+object present(mixed arg, object ob)
+{
+    if (ob->is_area())
+    {
+        int p = 0, index;
+        object *obs, t;
+        mapping area_info;
+
+        area_info = this_player()->query("area_info");
+
+        if (sscanf(arg, "%s %d", arg, index) != 2)
+            index = 1;
+
+        obs = ob->query_inventory(area_info["x_axis"], area_info["y_axis"]);
+
+        foreach (t in obs)
+        {
+            if (!objectp(t))
+                continue;
+            if (t->id(arg))
+            {
+                p += 1;
+                if (p == index)
+                    return t;
+            }
+        }
+        return 0;
+    }
+    else
+        return efun::present(arg, ob);
+}
diff --git a/include/area.h b/include/area.h
new file mode 100644
index 00000000..a9725921
--- /dev/null
+++ b/include/area.h
@@ -0,0 +1,21 @@
+/* area.h write by -Acme-
+*/
+
+#ifndef __AREA__
+#define __AREA__
+
+// 預設區域大小
+#define DEFAULT_XAXIS_SIZE  50
+#define DEFAULT_YAXIS_SIZE  20
+
+// 區域大小限制
+#define AREA_XAXIS_MIN      19
+#define AREA_YAXIS_MIN      11
+#define AREA_XAXIS_MAX     100
+#define AREA_YAXIS_MAX      100
+
+#define AREA_PROMPT_ICON    "/std/area/prompt_icon.c"
+#define AREA_MAP            "/std/area/map.c"
+#define AREA_BUILDING       "/std/area/build.c"
+
+#endif __AREA__
diff --git a/std/area.c b/std/area.c
new file mode 100644
index 00000000..e66f6be7
--- /dev/null
+++ b/std/area.c
@@ -0,0 +1,337 @@
+/* area.c write by -Acme-
+   這裡負責區域物件的載入、清除、重設等工作。
+*/
+
+// #pragma save_binary
+
+#include <area.h>
+#include <dbase.h>
+
+inherit F_DBASE;
+inherit F_CLEAN_UP;
+inherit F_SAVE;
+
+inherit AREA_MAP;
+inherit AREA_BUILDING;
+
+// 區域載入的物件集
+// Location Of Loaded Objects
+// 所有區域載入之物件的座標另成一個集合，以方便快速查找
+string *LOLO = ({});
+
+////////////////////////////////////////////////////////////
+// 一般設定、檢查、查詢
+////////////////////////////////////////////////////////////
+// 傳回有載入物件的座標集
+string *query_LOLO() { return LOLO; }
+// 加入一個座標元素在LOLO集中
+void add_LOLO(string location)
+{
+    if (member_array(location, LOLO) == -1)
+        LOLO += ({location});
+}
+// 刪除一個座標元素在LOLO集中
+void del_LOLO(string location)
+{
+    if (member_array(location, LOLO) != -1)
+        LOLO -= ({location});
+}
+
+// 儲存區域資料的路徑位置
+string query_save_file() { return file_name(this_object()); }
+
+// 絕對接受物件移入區域物件
+int receive_object(object ob, int from_inventory) { return 1; }
+
+// 區域檢查
+int is_area() { return 1; }
+
+// 設定某座標要載入的物件檔
+int set_loads(int x, int y, string filename, int amount)
+{
+    if (!check_scope(x, y))
+        return 0;
+    if (amount <= 0)
+        return 0;
+    if (undefinedp(area[y][x]["loads"]))
+        area[y][x]["loads"] = ([]);
+    area[y][x]["loads"][filename] = amount;
+
+    // 加入快速搜尋集
+    add_LOLO((string)y + "," + (string)x);
+    return 1;
+}
+
+// 將某座標要載入的物件檔移除
+int del_loads(int x, int y)
+{
+    if (!check_scope(x, y))
+        return 0;
+    if (undefinedp(area[y][x]["loads"]))
+        return 1;
+    map_delete(area[y][x], "loads");
+
+    // 移除快速搜尋集
+    del_LOLO((string)y + "," + (string)x);
+    return 1;
+}
+
+// 將某座標的已載入物件移除
+int del_loaded(int x, int y)
+{
+    if (!check_scope(x, y))
+        return 0;
+    if (undefinedp(area[y][x]["loaded"]))
+        return 1;
+    map_delete(area[y][x], "loaded");
+    return 1;
+}
+
+////////////////////////////////////////////////////////////
+// 區域裡的物件載入、清除
+////////////////////////////////////////////////////////////
+object make_inventory(string file, int x, int y)
+{
+    string *exits;
+    object ob;
+
+    file = file_path(file);
+    ob = new (file);
+
+    // Support for uniqueness
+    if (ob->violate_unique())
+        ob = ob->create_replica();
+    if (!ob)
+        return 0;
+
+    ob->set("area_info/x_axis", x);
+    ob->set("area_info/y_axis", y);
+    ob->set("area_info/x_axis_old", x);
+    ob->set("area_info/y_axis_old", y);
+
+    // 將物件移到區域裡，並檢查是否有guard某方向
+    if (move_in(x, y, ob))
+    {
+        if ((exits = ob->query("guard_exit")))
+        {
+            int i = sizeof(exits);
+            while (i--)
+                this_object()->set_area_guard(x, y, exits[i], ob);
+        }
+        ob->move(this_object());
+    }
+    else
+        destruct(ob);
+
+    return ob;
+}
+
+void reset_callout(int temp)
+{
+    int i, j, x, y, amount, t = 0;
+    mapping ob;
+    string file;
+
+    if (!sizeof(LOLO) || temp >= sizeof(LOLO))
+        return;
+
+    for (i = temp; i < sizeof(LOLO); i++)
+    {
+        if (sscanf(LOLO[i], "%d,%d", y, x) != 2)
+            continue;
+        if (!check_scope(x, y))
+            continue;
+        if (undefinedp(area[y][x]["loads"]))
+            continue;
+        if (!mapp(ob = area[y][x]["loaded"]))
+            ob = ([]);
+        foreach (file, amount in area[y][x]["loads"])
+        {
+            for (j = amount; j > 0; j--)
+            {
+                if (objectp(ob[file + " " + j]))
+                    continue;
+                ob[file + " " + j] = make_inventory(file, x, y);
+            }
+            area[y][x]["loaded"] = ob;
+        }
+        t++;
+        if (t >= 3)
+        {
+            call_out("reset_callout", 1, i + 1);
+            return;
+        }
+    }
+    return;
+}
+
+void reset()
+{
+    // 清空LOO座標集
+    LOO = ({});
+
+    // 物件載入集有資料, 遞迴延遲呼叫產生mob以免cost過多
+    call_out("reset_callout", 1, 0);
+    return;
+}
+
+int clean_up(int inherit_flag)
+{
+    int i, y, x;
+    mapping items;
+    string file;
+    object ob;
+
+    i = sizeof(LOLO);
+    while (i--)
+        if (sscanf(LOLO[i], "%d,%d", y, x) == 2)
+        {
+            if (!mapp(items = query_loaded(x, y)))
+                continue;
+            foreach (file, ob in items)
+                if (objectp(ob) && ob->is_character() && environment(ob) != this_object())
+                    return 1;
+        }
+
+    return ::clean_up(inherit_flag);
+}
+
+// 區域消滅時呼叫此函式
+void remove()
+{
+    int i, y, x, cnt;
+    mapping items;
+    string file;
+    object ob;
+
+    i = sizeof(LOLO);
+    while (i--)
+        if (sscanf(LOLO[i], "%d,%d", y, x) == 2)
+        {
+            if (!mapp(items = query_loaded(x, y)))
+                continue;
+            foreach (file, ob in items)
+            {
+                if (objectp(ob))
+                {
+                    message("vision", ob->name() + "化成輕飄飄的白煙消散了。\n", environment(ob));
+                    destruct(ob);
+                    cnt++;
+                }
+            }
+            // 清空座標物件集，以免往後出錯
+            map_delete(area[y][x], "objects");
+
+            // 清空座標已載入物件之資料，以免往後出錯
+            map_delete(area[y][x], "loaded");
+        }
+
+    if (cnt && this_player())
+        write("警告：" + cnt + " 個NPC由此區域創造並被強制刪除。\n");
+}
+
+int save()
+{
+    int i, j, x_size, y_size;
+    string *LOO_BAK;
+    mapping ICON_BAK, LOADED_BAK, OBJECTS_BAK;
+    mixed *AREA_BAK;
+
+    // 存檔前將不需要儲取的變數清空，以免往後發生無法預期的錯誤
+    LOO_BAK = LOO;
+    ICON_BAK = icon;
+    AREA_BAK = area;
+
+    LOO = ({});
+    icon = ([]);
+
+    LOADED_BAK = ([]);
+    OBJECTS_BAK = ([]);
+
+    x_size = this_object()->query("x_axis_size");
+    y_size = this_object()->query("y_axis_size");
+
+    // 每格座標中的暫時變數也要清空, 並暫存起來
+    for (i = 0; i < y_size; i++)
+    {
+        if (undefinedp(LOADED_BAK[i]))
+            LOADED_BAK[i] = ([]);
+        if (undefinedp(OBJECTS_BAK[i]))
+            OBJECTS_BAK[i] = ([]);
+        for (j = 0; j < x_size; j++)
+        {
+            LOADED_BAK[i][j] = area[i][j]["loaded"];
+            OBJECTS_BAK[i][j] = area[i][j]["objects"];
+            map_delete(area[i][j], "loaded");  // loaded -> mapping
+            map_delete(area[i][j], "objects"); // objects -> array
+        }
+    }
+
+    if (::save())
+    {
+        // 儲存完便還原
+        LOO = LOO_BAK;
+        icon = ICON_BAK;
+        area = AREA_BAK;
+
+        for (i = 0; i < y_size; i++)
+        {
+            for (j = 0; j < x_size; j++)
+            {
+                area[i][j]["loaded"] = LOADED_BAK[i][j];
+                area[i][j]["objects"] = OBJECTS_BAK[i][j];
+            }
+        }
+        return 1;
+    }
+
+    return 0;
+}
+
+void setup()
+{
+    int i;
+    string file;
+
+    seteuid(getuid());
+
+    // 沒有儲存檔
+    if (!restore())
+    {
+        int j, y_size, x_size;
+
+        // 將區域資料變數 area 作初始化
+        y_size = this_object()->query("y_axis_size");
+        x_size = this_object()->query("x_axis_size");
+        if (!y_size || y_size < AREA_YAXIS_MIN || y_size > AREA_YAXIS_MAX)
+            y_size = DEFAULT_YAXIS_SIZE;
+        if (!x_size || x_size < AREA_XAXIS_MIN || x_size > AREA_XAXIS_MAX)
+            x_size = DEFAULT_XAXIS_SIZE;
+
+        // 要求記憶體
+        area = allocate(y_size);
+        for (i = 0; i < sizeof(area); i++)
+        {
+            area[i] = allocate(x_size);
+            for (j = 0; j < sizeof(area[i]); j++)
+                area[i][j] = ([]);
+        }
+
+        // 清空相關物件集
+        LOO = ({});
+        LOLO = ({});
+
+        // 儲存
+        save();
+    }
+
+    // update 相對路徑
+    file = base_name(this_object());
+    i = strlen(file);
+    while (i--)
+        if (file[i..i] == "/")
+            break;
+    set("file_path", file[0..i]);
+
+    this_object()->reset();
+}
diff --git a/std/area/build.c b/std/area/build.c
new file mode 100644
index 00000000..c9f24ffa
--- /dev/null
+++ b/std/area/build.c
@@ -0,0 +1,511 @@
+/* 專門處理地圖上的build
+   Write by -Acme- 2009.03.24
+*/
+
+//#define BUILD_FOLDER "builds"
+#define BUILD_FILE_PATH "/world/builds/"
+
+mapping builds = ([]);
+int buildCount = 0;
+
+mapping getBuilds()
+{
+    return builds;
+}
+
+private int isBuildExist(string file)
+{
+    if (undefinedp(builds[file]))
+        return 0;
+    else
+        return 1;
+}
+
+// 取得build完整資料(mapping)
+mapping getBuild(string file)
+{
+    if (!isBuildExist(file))
+        return 0;
+    if (!mapp(builds[file]))
+        return 0;
+    return builds[file];
+}
+
+void setBuildTitle(string file, int index, string title)
+{
+    int shiftX, shiftY;
+    string temp, buildFile;
+
+    if (!isBuildExist(file))
+        return;
+    title = ansi(title);
+    if (strlen(remove_ansi(title)) > 2)
+        return;
+
+    buildFile = BUILD_FILE_PATH + builds[file]["style"] + ".c";
+    if (index <= 0)
+        return;
+    if (index > buildFile->getTitleLength())
+        return;
+
+    temp = buildFile->getTitlePosition(index);
+    if (sscanf(temp, "(%d,%d)", shiftX, shiftY) != 2)
+        return;
+    this_object()->set_data(builds[file]["x"] + shiftX, builds[file]["y"] + shiftY, "icon", title);
+
+    this_object()->save();
+}
+
+void setBuildOwner(string file, string id)
+{
+    if (!isBuildExist(file))
+        return;
+    builds[file]["owner"] = id;
+}
+
+// 取得區域的folder path
+private string getAreaFolderPath()
+{
+    int i;
+    string path;
+
+    path = file_name(this_object());
+    i = strsrch(path, "/", -1);
+
+    if (i == -1)
+        return 0;
+
+    return path[0..i];
+}
+
+// 取得區域中build的folder path
+string getBuildFolderPath()
+{
+    int i;
+    string path, filename;
+    if (!(path = getAreaFolderPath()))
+        return 0;
+
+    filename = file_name(this_object());
+    i = strsrch(path, "/", -1);
+    if (i == -1)
+        return 0;
+
+    path = path + filename[i + 1..strlen(filename)] + "/";
+    return path;
+}
+
+// 從座標取得build的file
+string getBuildFile(int x, int y)
+{
+    string buildFile;
+    if (!(buildFile = this_object()->query_data(x, y, "_BUILDING_FILE_")))
+        return 0;
+    if (undefinedp(builds[buildFile]))
+        return 0;
+    return buildFile;
+}
+
+// 檢查座標是否有building
+int hasBuilding(int x, int y)
+{
+    string buildFile;
+    if (!(buildFile = this_object()->query_data(x, y, "_BUILDING_FILE_")))
+        return 0;
+    if (undefinedp(builds[buildFile]))
+        return 0;
+    return 1;
+}
+
+// 從座標取得build的owner
+string getOwner(int x, int y)
+{
+    string buildFile;
+    if (!(buildFile = this_object()->query_data(x, y, "_BUILDING_FILE_")))
+        return 0;
+    if (undefinedp(builds[buildFile]))
+        return 0;
+    return builds[buildFile]["owner"];
+}
+
+private int isBuilding(int x, int y, string *checkPoints)
+{
+    int i, j, xMax, yMax;
+
+    yMax = sizeof(checkPoints);
+    for (i = 0; i < yMax; i++)
+    {
+        xMax = strlen(checkPoints[i]);
+        for (j = 0; j < xMax; j++)
+        {
+            if (checkPoints[i][j..j] == "0")
+                continue;
+
+            // 沒有設 _BUILDING_
+            if (!this_object()->query_data(x + j, y + i, "_BUILDING_"))
+                return 0;
+
+            // Block
+            if (this_object()->query_data(x + j, y + i, "block"))
+                return 0;
+
+            // 被佔領
+            if (hasBuilding(x + j, y + i))
+                return 0;
+        }
+    }
+
+    return 1;
+}
+
+private void toOccupy(int x, int y, string *occupy, string fileName)
+{
+    int i, j, xMax, yMax;
+
+    yMax = sizeof(occupy);
+    for (i = 0; i < yMax; i++)
+    {
+        xMax = strlen(occupy[i]);
+        for (j = 0; j < xMax; j++)
+        {
+            if (occupy[i][j..j] == "0")
+                continue;
+            if (stringp(fileName))
+            {
+                this_object()->set_data(x + j, y + i, "_BUILDING_FILE_", fileName);
+            }
+            else
+            {
+                this_object()->delete_data(x + j, y + i, "_BUILDING_FILE_");
+            }
+        }
+    }
+}
+
+private void setStyle(int x, int y, mapping icon)
+{
+    int i, j, style_size;
+    string *style_key, *style_value;
+
+    style_key = keys(icon);
+    style_size = sizeof(style_key);
+    for (i = 0; i < style_size; i++)
+    {
+        style_value = icon[i];
+        for (j = 0; j < sizeof(style_value); j++)
+        {
+            this_object()->set_data(x + j, y + i, "icon", style_value[j]);
+        }
+    }
+}
+
+private void setWall(int x, int y, string *wall, int on)
+{
+    int i, j, xMax, yMax;
+
+    yMax = sizeof(wall);
+    for (i = 0; i < yMax; i++)
+    {
+        xMax = strlen(wall[i]);
+        for (j = 0; j < xMax; j++)
+        {
+            if (wall[i][j..j] == "0")
+                continue;
+            if (!on)
+                this_object()->delete_data(x + j, y + i, "block");
+            else
+                this_object()->set_data(x + j, y + i, "block", on);
+        }
+    }
+}
+
+// create the building as room style
+private object createRoomBuilding(int x, int y, string buildFile, string filePath, string fileName)
+{
+    int i, exitX, exitY, exits_size;
+    string code, temp, *exits_key;
+    mapping exits, shift_exits;
+    object build;
+
+    code = BUILDING_D->getRoomCode();
+
+    // write file
+    if (!write_file(filePath + fileName, code))
+        return 0;
+    if (!objectp(build = load_object(filePath + fileName)))
+        return 0;
+
+    exits = buildFile->getExitPosition();
+    exits_key = keys(exits);
+    exits_size = sizeof(exits_key);
+    shift_exits = ([]);
+
+    for (i = 0; i < exits_size; i++)
+    {
+        temp = exits[exits_key[i]];
+        if (sscanf(temp, "(%d,%d)", exitX, exitY) != 2)
+            continue;
+
+        // setup build exits
+        shift_exits[exits_key[i]] = ([]);
+        shift_exits[exits_key[i]]["filename"] = file_name(this_object()) + ".c";
+        shift_exits[exits_key[i]]["x_axis"] = x + exitX;
+        shift_exits[exits_key[i]]["y_axis"] = y + exitY;
+
+        // setup area entry
+        this_object()->set_data(x + exitX, y + exitY, "room_exit", filePath + fileName);
+    }
+    build->set("exits", shift_exits);
+
+    return build;
+}
+
+// create the building as area style
+private object createAreaBuilding(int x, int y, string buildFile, string filePath, string fileName)
+{
+    int i, j, entryX, entryY, exitX, exitY, exits_size;
+    string code, temp, *exits_key;
+    mapping exits;
+    object build;
+
+    temp = buildFile->getAreaSize();
+    if (sscanf(temp, "(%d,%d)", exitX, exitY) != 2)
+        return 0;
+
+    code = BUILDING_D->getAreaCode(exitX, exitY);
+
+    // write file
+    if (!write_file(filePath + fileName, code))
+        return 0;
+    if (!objectp(build = load_object(filePath + fileName)))
+        return 0;
+
+    exits = buildFile->getExitPosition();
+    exits_key = keys(exits);
+    exits_size = sizeof(exits_key);
+
+    for (i = 0; i < exits_size; i++)
+    {
+        temp = exits_key[i];
+        if (sscanf(temp, "(%d,%d)", entryX, entryY) != 2)
+            continue;
+
+        temp = exits[exits_key[i]];
+        if (sscanf(temp, "(%d,%d)", exitX, exitY) != 2)
+            continue;
+
+        // setup build exits
+        build->set_area_exit(entryX, entryY, file_name(this_object()) + ".c", x + exitX, y + exitY);
+
+        // setup area entry
+        this_object()->set_area_exit(x + exitX, y + exitY, file_name(build) + ".c", entryX, entryY);
+    }
+
+    exits_key = buildFile->getBuilding();
+    exits_size = sizeof(exits_key);
+    for (i = 0; i < exits_size; i++)
+    {
+        for (j = 0; j < strlen(exits_key[i]); j++)
+        {
+            if (exits_key[i][j..j] == "0")
+                continue;
+            build->set_data(j, i, "_BUILDING_", 1);
+        }
+    }
+
+    return build;
+}
+
+int createBuilding(string style, string owner, int x, int y)
+{
+    int checkX, checkY;
+    string buildFile, temp;
+    string filePath, fileName;
+    object build;
+
+    // 取得 buildFile 檔
+    buildFile = BUILD_FILE_PATH + style + ".c";
+    if (file_size(buildFile) == -1)
+        return 0;
+
+    // 是一個area build
+    if (this_object()->isBuild() && buildFile->isAreaBuilding())
+        return 0;
+
+    // 檢查能否建立build
+    temp = buildFile->getCheckPointsPosition();
+    if (sscanf(temp, "(%d,%d)", checkX, checkY) != 2)
+        return 0;
+    checkX += x;
+    checkY += y;
+    if (!isBuilding(checkX, checkY, buildFile->getCheckPoints()))
+        return 0;
+
+    // get file path
+    if (!(filePath = getBuildFolderPath()))
+        return 0;
+
+    // mkdir, if dir not exist
+    if (file_size(filePath) == -1)
+        if (!mkdir(filePath))
+            return 0;
+
+    // get file name
+    fileName = "building" + buildCount + ".c";
+
+    if (buildFile->isRoomBuilding())
+    {
+        build = createRoomBuilding(checkX, checkY, buildFile, filePath, fileName);
+    }
+    else if (buildFile->isAreaBuilding())
+    {
+        build = createAreaBuilding(checkX, checkY, buildFile, filePath, fileName);
+    }
+
+    if (!objectp(build))
+        return 0;
+    buildCount++;
+
+    // build可以自訂建好後的設定
+    buildFile->postCondition(build);
+    build->set("owner", owner);
+    build->save();
+
+    // 設定build的position(左上)
+    builds[fileName] = ([]);
+    builds[fileName]["x"] = checkX;
+    builds[fileName]["y"] = checkY;
+
+    builds[fileName]["style"] = style;
+    builds[fileName]["owner"] = owner;
+
+    // 設定佔領
+    toOccupy(checkX, checkY, buildFile->toOccupy(), fileName);
+
+    // 設定icon
+    setStyle(checkX, checkY, buildFile->getStyle(1));
+
+    // 設定牆
+    setWall(checkX, checkY, buildFile->getWall(), 1);
+
+    this_object()->save();
+
+    return 1;
+}
+
+private void removeEntry(int x, int y, string buildFile)
+{
+    if (buildFile->isRoomBuilding())
+    {
+        int i, exitX, exitY, exits_size;
+        string *exits_key, temp;
+        mapping exits;
+
+        exits = buildFile->getExitPosition();
+        exits_key = keys(exits);
+        exits_size = sizeof(exits_key);
+
+        for (i = 0; i < exits_size; i++)
+        {
+            temp = exits[exits_key[i]];
+            if (sscanf(temp, "(%d,%d)", exitX, exitY) != 2)
+                continue;
+            this_object()->delete_data(x + exitX, y + exitY, "room_exit");
+        }
+    }
+    else if (buildFile->isAreaBuilding())
+    {
+        int i, exitX, exitY, exits_size;
+        string *exits_key, temp;
+        mapping exits;
+
+        exits = buildFile->getExitPosition();
+        exits_key = keys(exits);
+        exits_size = sizeof(exits_key);
+
+        for (i = 0; i < exits_size; i++)
+        {
+            temp = exits[exits_key[i]];
+            if (sscanf(temp, "(%d,%d)", exitX, exitY) != 2)
+                continue;
+
+            // remove area entry
+            this_object()->delete_data(x + exitX, y + exitY, "area_exit");
+        }
+    }
+}
+
+private void rmfile(string fileName)
+{
+    // rm .c
+    rm(fileName);
+
+    // rm .o file
+    fileName = fileName[0..strlen(fileName)-2] + "o";
+    rm(fileName);
+}
+
+// 摧毀building
+int destBuilding(int x, int y)
+{
+    string fileName, buildFile;
+
+    // 沒被佔領
+    if (!hasBuilding(x, y))
+        return 0;
+
+    if (!(fileName = getBuildFile(x, y)))
+        return 0;
+
+    // if build file not exist
+    buildFile = BUILD_FILE_PATH + builds[fileName]["style"] + ".c";
+    if (file_size(buildFile) == -1)
+        return 0;
+
+    // 先清空area building裡的東西
+    if (buildFile->isAreaBuilding())
+    {
+        int i, builds_size;
+        object build;
+        mapping builds;
+        string *builds_key, filepath;
+
+        build = load_object(getBuildFolderPath() + fileName);
+        if (!objectp(build))
+            return 0;
+
+        builds = build->getBuilds();
+        if (!mapp(builds))
+            return 0;
+
+        builds_key = keys(builds);
+        builds_size = sizeof(builds_key);
+
+        filepath = build->getBuildFolderPath();
+        for (i = 0; i < builds_size; i++)
+            rmfile(filepath + builds_key[i]);
+        rmdir(filepath);
+    }
+
+    // 移掉佔領
+    toOccupy(builds[fileName]["x"], builds[fileName]["y"], buildFile->toOccupy(), 0);
+
+    // 移掉icon
+    setStyle(builds[fileName]["x"], builds[fileName]["y"], buildFile->getStyle(0));
+
+    // 移掉牆
+    setWall(builds[fileName]["x"], builds[fileName]["y"], buildFile->getWall(), 0);
+
+    // 移掉入口
+    removeEntry(builds[fileName]["x"], builds[fileName]["y"], buildFile);
+
+    this_object()->save();
+
+    // delete mapping info
+    map_delete(builds, fileName);
+
+    fileName = getBuildFolderPath() + fileName;
+    rmfile(fileName);
+
+    return 1;
+}
diff --git a/std/area/map.c b/std/area/map.c
new file mode 100644
index 00000000..40c276c3
--- /dev/null
+++ b/std/area/map.c
@@ -0,0 +1,860 @@
+/* map.c write by -Acme-
+   這裡負責地圖的顯示、物件的移動以及一些設定等等。
+*/
+
+// #pragma save_binary
+
+#include <area.h>
+#include <ansi.h>
+#include <dbase.h>
+
+inherit AREA_PROMPT_ICON;
+
+// 區域座標資料(座標物件、圖樣...)
+mixed *area;
+
+// Location Of Objects
+// 所有存在物件的座標另成一個集合，以方便快速查找
+string *LOO = ({});
+
+// 不能用一般設定方法的項目 (區域形式的出口，要用特別的方式設定)
+string *set_data_resist = ({"objects", "loaded", "loads", "area_exit"});
+
+// 不能用一般刪除方法的項目 (可能是區域管理用的項目或其它特別的項目)
+string *delete_data_resist = ({"objects", "loaded", "loads"});
+
+varargs int do_look(object me, string arg);
+
+////////////////////////////////////////////////////////////
+// 一般設定、檢查、查詢
+////////////////////////////////////////////////////////////
+// 傳回有物件存在的座標集
+string *query_LOO() { return LOO; }
+// 加入一個座標元素在LOO集中
+void add_LOO(string location)
+{
+    if (member_array(location, LOO) == -1)
+        LOO += ({location});
+}
+// 刪除一個座標元素在LOO集中
+void del_LOO(string location)
+{
+    if (member_array(location, LOO) != -1)
+        LOO -= ({location});
+}
+
+// 使用__DIR__之相對路徑
+string file_path(string dir)
+{
+    dir = replace_string(dir, "__DIR__", query("file_path"));
+    dir = replace_string(dir, "_DIR_AREA_", _DIR_AREA_);
+    dir = replace_string(dir, "_DIR_NPC_", _DIR_NPC_);
+    dir = replace_string(dir, "_DIR_WP_", _DIR_WP_);
+    dir = replace_string(dir, "_DIR_EQ_", _DIR_EQ_);
+    dir = replace_string(dir, "_DIR_ITEM_", _DIR_ITEM_);
+    dir = replace_string(dir, "_DIR_WORLD_", _DIR_WORLD_);
+    return dir;
+}
+
+// 座標範圍檢查
+int check_scope(int x, int y)
+{
+    if (y < 0 || x < 0 || y >= sizeof(area) || x >= sizeof(area[y]))
+        return 0;
+    return 1;
+}
+
+// 查詢某座標的資訊
+mapping *query_info(int x, int y)
+{
+    if (!check_scope(x, y))
+        return 0;
+    return area[y][x];
+}
+
+// 查詢某座標載入的物件
+mapping query_loaded(int x, int y)
+{
+    if (!check_scope(x, y))
+        return ([]);
+    return area[y][x]["loaded"];
+}
+
+// 查詢區域中某座標的物件集
+//mapping *query_inventory(int x, int y)
+object *query_inventory(int x, int y)
+{
+    if (!check_scope(x, y))
+        return ({});
+    if (undefinedp(area[y][x]["objects"]))
+        return ({});
+    return area[y][x]["objects"];
+}
+
+// 設定區域型出口
+int set_area_exit(int x, int y, string filename, int exit_x, int exit_y)
+{
+    if (!check_scope(x, y))
+        return 0;
+    area[y][x]["area_exit"] = ([]);
+    area[y][x]["area_exit"]["filename"] = filename;
+    area[y][x]["area_exit"]["x_axis"] = exit_x;
+    area[y][x]["area_exit"]["y_axis"] = exit_y;
+    return 1;
+}
+
+// 設定區域細節描述
+int set_area_detail(int x, int y, string title, string detail)
+{
+    if (!check_scope(x, y))
+        return 0;
+    if (undefinedp(area[y][x]["detail"]))
+        area[y][x]["detail"] = ([]);
+    area[y][x]["detail"][title] = detail;
+    return 1;
+}
+
+// 刪除區域細節描述
+int del_area_detail(int x, int y, string title)
+{
+    if (!check_scope(x, y))
+        return 0;
+    if (undefinedp(area[y][x]["detail"]))
+        return 1;
+
+    map_delete(area[y][x]["detail"], title);
+
+    if (sizeof(area[y][x]["detail"]) < 1)
+        map_delete(area[y][x], "detail");
+    return 1;
+}
+
+// 取得區域細節資料
+mapping query_area_detail(int x, int y)
+{
+    if (!check_scope(x, y))
+        return 0;
+    if (undefinedp(area[y][x]["detail"]))
+        return ([]);
+    return area[y][x]["detail"];
+}
+
+// 取得某detail的描述
+string query_area_detail_arug(int x, int y, string title)
+{
+    if (!check_scope(x, y))
+        return 0;
+    if (undefinedp(area[y][x]["detail"]))
+        return 0;
+    if (undefinedp(area[y][x]["detail"][title]))
+        return 0;
+    return area[y][x]["detail"][title];
+}
+
+// 設定某方向的guard
+int set_area_guard(int x, int y, string exit, object ob)
+{
+    if (!check_scope(x, y))
+        return 0;
+    if (!objectp(ob))
+        return 0;
+    if (undefinedp(area[y][x]["guard"]))
+        area[y][x]["guard"] = ([]);
+    if (undefinedp(area[y][x]["guard"][exit]))
+        area[y][x]["guard"][exit] = ({});
+    area[y][x]["guard"][exit] += ({ob});
+    return 1;
+}
+
+// 查詢某方向是否被guard
+int query_area_guard(int x, int y, string exit)
+{
+    int index;
+    object guard;
+    if (!check_scope(x, y))
+        return 0;
+    if (undefinedp(area[y][x]["guard"]))
+        return 0;
+    if (undefinedp(area[y][x]["guard"][exit]))
+        return 0;
+    if (!(index = sizeof(area[y][x]["guard"][exit])))
+        return 0;
+    while (index--)
+    {
+        if (objectp(guard = area[y][x]["guard"][exit][index]))
+            if (guard->query("area_info/x_axis") == x && guard->query("area_info/y_axis") == y)
+                if (guard->do_guard_exit(x, y, exit))
+                    return 1;
+    }
+    return 0;
+}
+
+// 設定一般資料
+int set_data(int x, int y, string type, mixed value)
+{
+    if (member_array(type, set_data_resist) != -1)
+        return 0;
+    if (!check_scope(x, y))
+        return 0;
+    area[y][x][type] = value;
+    return 1;
+}
+
+// 刪除一般資料
+int delete_data(int x, int y, string type)
+{
+    if (member_array(type, delete_data_resist) != -1)
+        return 0;
+    if (!check_scope(x, y))
+        return 0;
+    if (undefinedp(area[y][x][type]))
+        return 1;
+    map_delete(area[y][x], type);
+    return 1;
+}
+
+// 取得一般資料
+mixed query_data(int x, int y, string type)
+{
+    if (member_array(type, delete_data_resist) != -1)
+        return 0;
+    if (!check_scope(x, y))
+        return 0;
+    if (undefinedp(area[y][x][type]))
+        return 0;
+    return area[y][x][type];
+}
+
+////////////////////////////////////////////////////////////
+// 移動
+////////////////////////////////////////////////////////////
+
+// 檢查某座標是否有障礙物，是否可穿透
+int is_move(int x, int y)
+{
+    // 如果巫師設定為穿牆模式
+    if (wizardp(this_player()) && this_player()->query("option/map_through"))
+        return 1;
+    if (!check_scope(x, y))
+        return 0;
+    if (undefinedp(area[y][x]["block"]))
+        return 1;
+    if (!area[y][x]["block"])
+        return 1;
+    return 0;
+}
+
+// 物件移入某座標處理
+int move_in(int x, int y, object ob)
+{
+    // 超出區域大小範圍
+    if (!check_scope(x, y))
+        return 0;
+
+    // 該座標沒有物件集(objects)，則將物件集設為空
+    if (undefinedp(area[y][x]["objects"]))
+        area[y][x]["objects"] = ({});
+
+    // 一格最多容納30個物件
+    /*
+    if( sizeof(area[y][x]["objects"]) >= 30 ) {
+        write("那個方向太多東西了。\n");
+        return 0;
+    }
+*/
+    // 物件已經存在物件集(objects)中，就不需要再加入物件集
+    if (member_array(ob, area[y][x]["objects"]) != -1)
+        return 1;
+
+    // 物件加入物件集中
+    area[y][x]["objects"] += ({ob});
+
+    // 改變即時的圖示
+    set_icon_weight(x, y, get_icon_weight(ob));
+
+    // 增加LOO搜尋集
+    add_LOO((string)y + "," + (string)x);
+
+    return 1;
+}
+
+// 物件移出某座標處理
+int move_out(int x, int y, object ob)
+{
+    // 超出區域大小範圍
+    if (!check_scope(x, y))
+        return 0;
+
+    // 該座標沒有物件集(objects)
+    if (undefinedp(area[y][x]["objects"]))
+        return 1;
+
+    // 改變即時的圖示
+    set_icon_weight(x, y, -get_icon_weight(ob));
+
+    // 物件不存在於物件集(objects)中，就不需要再移出物件集
+    if (member_array(ob, area[y][x]["objects"]) == -1)
+        return 1;
+
+    // 物件移出物件集
+    area[y][x]["objects"] -= ({ob});
+
+    // 座標完全沒物件時，刪除物件集
+    if (sizeof(area[y][x]["objects"]) < 1)
+    {
+        map_delete(area[y][x], "objects");
+        // 刪除LOO搜尋集
+        del_LOO((string)y + "," + (string)x);
+    }
+
+    return 1;
+}
+
+// 進行移動
+// 物件是否合法的在區域中移動
+int valid_leave(object ob, string dir)
+{
+    int x, y, x_past, y_past;
+    x_past = ob->query("area_info/x_axis");
+    y_past = ob->query("area_info/y_axis");
+
+    // 座標轉換
+    switch (dir)
+    {
+    case "north":
+        y = y_past - 1;
+        x = x_past;
+        break;
+    case "east":
+        y = y_past;
+        x = x_past + 1;
+        break;
+    case "south":
+        y = y_past + 1;
+        x = x_past;
+        break;
+    case "west":
+        y = y_past;
+        x = x_past - 1;
+        break;
+    case "northeast":
+        y = y_past - 1;
+        x = x_past + 1;
+        break;
+    case "southeast":
+        y = y_past + 1;
+        x = x_past + 1;
+        break;
+    case "southwest":
+        y = y_past + 1;
+        x = x_past - 1;
+        break;
+    case "northwest":
+        y = y_past - 1;
+        x = x_past - 1;
+        break;
+    default:
+        return 0;
+        break;
+    }
+
+    // 無法移動至該座標(有障礙物)
+    if (!check_scope(x, y) || !is_move(x, y))
+    {
+        write("這個方向沒有出路");
+        return 0;
+    }
+
+    // 無法往某方向移動因為被某人guard
+    if (query_area_guard(x_past, y_past, dir))
+        return 0;
+
+    //////////////////////////////
+    // 移往別的房間
+    //////////////////////////////
+    if (!undefinedp(area[y][x]["room_exit"]))
+    {
+        object room;
+        if (!objectp(room = load_object(file_path(area[y][x]["room_exit"]))))
+        {
+            write("這個方向的出口有問題，請通知管理者來處理。\n");
+            return 0;
+        }
+        if (room->is_area())
+        {
+            write("這個方向的出口有問題，請通知管理者來處理。\n");
+            return 0;
+        }
+        else
+        {
+            // 如果成功移到房間, move 會自動在先前的area裡做move_out動作
+            if (ob->move(room))
+                return 1;
+            else
+            {
+                write("這個方向的出口有問題，請通知管理者來處理。\n");
+                return 0;
+            }
+        }
+        return 0;
+    }
+
+    //////////////////////////////
+    // 移往別的區域
+    //////////////////////////////
+    if (!undefinedp(area[y][x]["area_exit"]))
+    {
+        object room;
+        if (!objectp(room = load_object(file_path(area[y][x]["area_exit"]["filename"]))))
+        {
+            write("這個方向的出口有問題，請通知管理者來處理。\n");
+            return 0;
+        }
+        if (!room->is_area())
+        {
+            write("這個方向的出口有問題，請通知管理者來處理。\n");
+            return 0;
+        }
+
+        if (!area_move(room, ob, area[y][x]["area_exit"]["x_axis"], area[y][x]["area_exit"]["y_axis"]))
+        {
+            write("這個方向的出口有問題，請通知管理者來處理。\n");
+            return 0;
+        }
+        return 1;
+    }
+
+    //////////////////////////////
+    // 移進build
+    //////////////////////////////
+    /*
+    if( !undefinedp(area[y][x]["_BUILDING_FILE_"]) ) {
+        object room;
+        if( !objectp(room = load_object( this_object()->getBuildFolderPath() + area[y][x]["_BUILDING_FILE_"] )) ) {
+            write("這個方向的出口有問題，請通知管理者來處理。\n");
+            return 0;
+        }
+        if( room->is_area() ) {
+            if( !area_move(room, ob, room->query("entryX"), room->query("entryY")) )
+                write("這個方向的出口有問題，請通知管理者來處理。\n");
+            return 0;
+        } else {
+            // 如果成功移到房間, move 會自動在先前的area裡做move_out動作
+            if( ob->move(room) ) return 1;
+            else {
+                write("這個方向的出口有問題，請通知管理者來處理。\n");
+                return 0;
+            }
+        }
+        return 0;
+    }
+    */
+    //////////////////////////////
+    // 在區域中移動
+    //////////////////////////////
+    // 物件移出舊座標
+    if (move_out(x_past, y_past, ob))
+    {
+        // 物件移入新座標
+        if (move_in(x, y, ob))
+        {
+            ob->set("area_info/x_axis", x);
+            ob->set("area_info/y_axis", y);
+            ob->set("area_info/x_axis_old", x);
+            ob->set("area_info/y_axis_old", y);
+        }
+        else
+        {
+            // 物件移入失敗，退回原座標
+            move_in(x_past, y_past, ob);
+            return 0;
+        }
+        if (userp(ob))
+            do_look(ob, 0);
+    }
+    else
+        return 0;
+
+    return 1;
+}
+
+////////////////////////////////////////////////////////////
+// 檢視區域環境
+////////////////////////////////////////////////////////////
+
+// 查詢某坐標的出口
+string *query_exits(int x, int y, int option)
+{
+    string *exits = ({});
+
+    if (!option)
+    {
+        // 往北可能有路
+        if (y - 1 >= 0)
+        {
+            if (x - 1 >= 0 && is_move(x - 1, y - 1))
+                exits += ({"northwest"});
+            if (x >= 0 && is_move(x, y - 1))
+                exits += ({"north"});
+            if (x + 1 < sizeof(area[0]) && is_move(x + 1, y - 1))
+                exits += ({"northeast"});
+        }
+
+        // 往南可能有路
+        if (y + 1 < sizeof(area))
+        {
+            if (x - 1 >= 0 && is_move(x - 1, y + 1))
+                exits += ({"southwest"});
+            if (x >= 0 && is_move(x, y + 1))
+                exits += ({"south"});
+            if (x + 1 < sizeof(area[0]) && is_move(x + 1, y + 1))
+                exits += ({"southeast"});
+        }
+
+        // 往東可能有路
+        if (x + 1 < sizeof(area[0]) && is_move(x + 1, y))
+            exits += ({"east"});
+
+        // 往西可能有路
+        if (x - 1 >= 0 && is_move(x - 1, y))
+            exits += ({"west"});
+    }
+    else
+    {
+        // 往北可能有路
+        if (y - 1 >= 0)
+        {
+            if (x - 1 >= 0 && is_move(x - 1, y - 1))
+                exits += ({"西北(" HIK "nw" NOR ")"});
+            if (x >= 0 && is_move(x, y - 1))
+                exits += ({"北(" HIK "n" NOR ")"});
+            if (x + 1 < sizeof(area[0]) && is_move(x + 1, y - 1))
+                exits += ({"東北(" HIK "ne" NOR ")"});
+        }
+
+        // 往南可能有路
+        if (y + 1 < sizeof(area))
+        {
+            if (x - 1 >= 0 && is_move(x - 1, y + 1))
+                exits += ({"西南(" HIK "sw" NOR ")"});
+            if (x >= 0 && is_move(x, y + 1))
+                exits += ({"南(" HIK "s" NOR ")"});
+            if (x + 1 < sizeof(area[0]) && is_move(x + 1, y + 1))
+                exits += ({"東南(" HIK "se" NOR ")"});
+        }
+
+        // 往東可能有路
+        if (x + 1 < sizeof(area[0]) && is_move(x + 1, y))
+            exits += ({"東(" HIK "e" NOR ")"});
+
+        // 往西可能有路
+        if (x - 1 >= 0 && is_move(x - 1, y))
+            exits += ({"西(" HIK "w" NOR ")"});
+    }
+    return exits;
+}
+
+// 地圖顯示
+varargs string show_area(int x, int y, int type)
+{
+    int i, j, x_start, y_start, x_size, y_size;
+    string msg;
+
+    // 決定顯示地圖的Y軸起點, X軸起點
+    y_size = sizeof(area);
+    x_size = sizeof(area[0]);
+
+    if (y <= 5 || y_size <= 11)
+        y_start = 0;
+    else if (y >= y_size - 6)
+        y_start = y_size - 11;
+    else
+        y_start = y - 5;
+
+    if (x <= 9 || x_size <= 19)
+        x_start = 0;
+    else if (x >= x_size - 9)
+        x_start = x_size - 19;
+    else
+        x_start = x - 9;
+
+    // 建立即時地圖
+    msg = sprintf(BBLU "╲" U " %-21s %s (%2d,%2d) " NOR + BBLU "╱\n" NOR,
+                  query("name") + (area[y][x]["short"] ? " - " + area[y][x]["short"] : ""),
+                  (area[y][x]["no_fight"] ? "非戰區" : "戰鬥區"), x, y, );
+
+    for (i = y_start; i < y_size && i < y_start + 11; i++)
+    {
+        msg += BBLU "▕" NOR;
+        for (j = x_start; j < x_size && j < x_start + 19; j++)
+        {
+            if (y == i && x == j)
+                msg += HIY "⊕" NOR;
+            else if (undefinedp(area[i][j]["icon"]) &&
+                     (!undefinedp(area[i][j]["room_exit"]) || !undefinedp(area[i][j]["area_exit"])))
+                msg += HIW "。" NOR;
+            else
+            {
+                int check = 1;
+                if (check && (type & 2) == 2)
+                {
+                    // 座標有設不即時變更圖示
+                    if (!area[i][j]["nonprompt_icon"] && check_icon(j, i))
+                    {
+                        msg += get_icon(j, i);
+                        check = 0;
+                    }
+                }
+                if (check)
+                {
+                    if ((type & 8) == 8)
+                    {
+                        if (area[i][j]["_BUILDING_"])
+                        {
+                            if (!area[i][j]["_BUILDING_FILE_"])
+                                msg += "。";
+                            else
+                                msg += area[i][j]["icon"];
+                            check = 0;
+                        }
+                    }
+                    if (check && (type & 4) == 4)
+                    {
+                        if (area[i][j]["block"])
+                        {
+                            msg += "■";
+                            check = 0;
+                        }
+                        else
+                        {
+                            msg += "  ";
+                            check = 0;
+                        }
+                    }
+                }
+
+                // 圖形未定
+                if (check)
+                    msg += area[i][j]["icon"] ? area[i][j]["icon"] : "  ";
+            }
+        }
+        msg += BBLU "▏" NOR;
+        msg += "\n";
+    }
+    msg += BBLU "╱￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣╲\n" NOR;
+
+    if ((type & 1) == 1)
+        return msg;
+    else
+        return SAVEC + HOME + msg + RESTC;
+}
+
+varargs string show_objects(int x, int y, int type)
+{
+    string str = "";
+    object ob;
+
+    if (undefinedp(area[y][x]["objects"]))
+        return "";
+
+    if (sizeof(area[y][x]["objects"]) >= 30)
+        return "這裡的東西太多，一時看不清楚...\n";
+
+    foreach (ob in area[y][x]["objects"])
+    {
+        if (ob == this_player())
+            continue;
+        if (!objectp(ob) || environment(ob) != this_object() ||
+            ob->query("area_info/y_axis") != y || ob->query("area_info/x_axis") != x)
+        {
+            area[y][x]["objects"] -= ({ob});
+            continue;
+        }
+        if (!userp(ob) && QUEST_D->hasQuest(this_player(), ob))
+            str += sprintf("%s%s\n", BLINK + HIY "！" NOR, ob->short());
+        else
+            str += sprintf("  %s\n", ob->short());
+    }
+
+    /*  debug 用
+    whos = all_inventory(this_object());
+    str += sprintf("\n====== Environment_Objects (%d) ======\n", sizeof(whos));
+    for (i = 0; i < sizeof(whos); i++)
+    {
+        str += sprintf("  %s(%s) -> (%d,%d)\n",
+                       whos[i]->query("name"),
+                       whos[i]->query("id"),
+                       whos[i]->query("area_info/x_axis"),
+                       whos[i]->query("area_info/y_axis"));
+    }
+    */
+    return str;
+}
+
+varargs int do_look(object me, string arg)
+{
+    int i = 0, op = 0;
+    string str = "", *exits;
+    mapping info, option;
+
+    if (!userp(me))
+        return 0;
+
+    info = me->query("area_info");
+    option = me->query("option");
+
+    if (!info)
+        return 0;
+    if (!option)
+        option = ([]);
+    if (!check_scope(info["x_axis"], info["y_axis"]))
+        return 0;
+
+    if (arg)
+    {
+        if ((str = query_area_detail_arug(info["x_axis"], info["y_axis"], arg)))
+            message("vision", str + "\n", me);
+        else
+            return notify_fail("你要看什麼？\n");
+        return 1;
+    }
+
+    // 是否取消凍結即時地圖
+    if (option["map_unfreeze"])
+        op = op | 1;
+
+    // 顯示即時圖形變換
+    if (!option["map_obj_icon_hidden"])
+        op = op | 2;
+
+    // 將原本的地圖圖形變換成二種 有障礙物 與 沒障礙物
+    if (option["map_block"])
+        op = op | 4;
+
+    // 地圖圖形只顯示建築物及建地
+    if (option["map_build"])
+        op = op | 8;
+
+    // 顯示地圖
+    if (!option["map_hidden"])
+    {
+        str = show_area(info["x_axis"], info["y_axis"], op);
+    }
+
+    // 出口提示
+    if (!option["map_exits_hidden"])
+    {
+        exits = query_exits(info["x_axis"], info["y_axis"], 1);
+        if ((i = sizeof(exits)))
+        {
+            str += "這裡的出口有 ";
+            while (i--)
+                str += exits[i] + (i ? "、" : "。\n");
+        }
+        else
+            str += "這裡沒有任何出口。\n";
+    }
+    // 顯示物件
+    if (!option["map_obj_hidden"])
+        str += show_objects(info["x_axis"], info["y_axis"], 0);
+    message("vision", str, me);
+
+    return 1;
+}
+
+varargs int map_ansi_save()
+{
+    int i, j, x, y;
+    string file, msg = "", msg2 = "";
+
+    y = sizeof(area);
+    x = sizeof(area[0]);
+
+    file = base_name(this_object());
+
+    for (i = 0; i < y; i++)
+    {
+        for (j = 0; j < x; j++)
+        {
+            if (j <= 49)
+            {
+                if (undefinedp(area[i][j]["icon"]))
+                    msg += "  ";
+                else
+                    msg += area[i][j]["icon"];
+            }
+            else
+            {
+                if (undefinedp(area[i][j]["icon"]))
+                    msg2 += "  ";
+                else
+                    msg2 += area[i][j]["icon"];
+            }
+        }
+        msg += "\n";
+        if (x > 49)
+            msg2 += "\n";
+    }
+
+    if (x <= 49)
+    {
+        if (!write_file(file + ".ansi", msg, 1))
+            write("儲存ANSI檔失敗。\n");
+        else
+            write("儲存ANSI檔成功(" + file + ".ansi)。\n");
+    }
+    else
+    {
+        write("因為此area寬度超過五十個字大小，故分成左右二個圖檔儲存。\n");
+        if (!write_file(file + "_left.ansi", msg, 1))
+            write("儲存左半邊ANSI檔失敗。\n");
+        else
+            write("儲存左半邊ANSI檔成功(" + file + "_left.ansi)。\n");
+        if (!write_file(file + "_right.ansi", msg2, 1))
+            write("儲存右半邊ANSI檔失敗。\n");
+        else
+            write("儲存右半邊ANSI檔成功(" + file + "_right.ansi)。\n");
+    }
+
+    return 1;
+}
+
+varargs int map_html_save()
+{
+    int i, j, x, y;
+    string file, msg = "", tmp;
+
+    y = sizeof(area);
+    x = sizeof(area[0]);
+
+    file = base_name(this_object());
+
+    msg += "<html>\n";
+    msg += "<head>\n";
+    msg += "<title>" + this_object()->query("name") + "</title>\n";
+    msg += "</head>\n";
+    msg += "<body bgcolor=000000><font size=2 face=細明體>\n";
+    for (i = 0; i < y; i++)
+    {
+        for (j = 0; j < x; j++)
+        {
+            if (undefinedp(area[i][j]["icon"]))
+                msg += "　";
+            else
+            {
+                tmp = replace_string(area[i][j]["icon"], "  ", "　");
+                msg += color_to_html(tmp);
+                msg += "</span>";
+            }
+        }
+        msg += "\n<br>";
+    }
+    msg += "</font></body>\n</html>";
+
+    if (!write_file(file + ".html", msg, 1))
+        write("儲存HTML檔失敗。\n");
+
+    write("儲存HTML檔成功。\n");
+
+    return 1;
+}
diff --git a/std/area/prompt_icon.c b/std/area/prompt_icon.c
new file mode 100644
index 00000000..8dbe5f45
--- /dev/null
+++ b/std/area/prompt_icon.c
@@ -0,0 +1,87 @@
+/* prompt_icon.c
+   即時變換的圖示
+*/
+
+// #pragma save_binary
+
+#include <ansi.h>
+
+mapping icon = ([]);
+
+mapping query_icon() { return icon; }
+
+// 取得某物件權重
+int get_icon_weight(object ob)
+{
+    if (wizardp(ob))
+        return 27930;
+    else if (userp(ob))
+        return 931;
+    else if (living(ob))
+        return 31;
+    else if (objectp(ob))
+        return 1;
+    else
+        return 0;
+}
+
+// 設定某座標權重
+int set_icon_weight(int x, int y, int value)
+{
+    string coord;
+
+    if (!this_object())
+        return 0;
+    if (!this_object()->check_scope(x, y))
+        return 0;
+
+    coord = (string)x + "," + (string)y;
+
+    icon[coord] += value;
+
+    if (icon[coord] <= 0)
+        map_delete(icon, coord);
+
+    return 1;
+}
+
+int check_icon(int x, int y)
+{
+    if (undefinedp(icon[(string)x + "," + (string)y]))
+        return 0;
+    else
+        return 1;
+}
+
+string get_icon(int x, int y)
+{
+    string coord;
+    coord = (string)x + "," + (string)y;
+    if (icon[coord] >= 27930)
+        return HIY "♀" NOR;
+    else if (icon[coord] >= 931)
+        return HIK "♀" NOR;
+    else if (icon[coord] >= 31)
+        return HIR "♀" NOR;
+    else if (icon[coord] >= 1)
+        return "〥";
+    else
+        return "  ";
+}
+
+// 移除某座標圖樣
+int remove_icon(int x, int y)
+{
+    if (!undefinedp(icon[(string)x + "," + (string)y]))
+        return 1;
+    else if (map_delete(icon, (string)x + "," + (string)y))
+        return 1;
+    return 0;
+}
+
+// 刪除所有圖示集
+int delete_icon()
+{
+    icon = ([]);
+    return 1;
+}
diff --git a/std/build.c b/std/build.c
new file mode 100644
index 00000000..777ac699
--- /dev/null
+++ b/std/build.c
@@ -0,0 +1,103 @@
+// write by -Acme-
+#include <ansi.h>
+
+inherit ROOM;
+inherit F_SAVE;
+
+int isBuild() { return 1; }
+
+void create()
+{
+    set("short", "空地");
+    set("long", "這是一塊什麼也沒有的空地。\n");
+    setup();
+    restore();
+}
+
+string query_save_file() { return file_name(this_object()); }
+
+void init()
+{
+    // 不是巫師且不是擁有者，是不能有動作的
+    if (this_object()->query("owner") != this_player()->query_id() && !wizardp(this_player()))
+        return;
+
+    // 一般共用指令
+    add_action("do_set_short", "short"); // 設定房間short
+    add_action("do_set_long", "long");   // 設定房間long
+
+    if (this_object()->query("_IS_WELL_"))
+        add_action("do_drink", "drink");
+}
+
+int do_set_short(string arg)
+{
+    object me;
+    me = this_player();
+
+    if (!arg)
+        return notify_fail("你要設什麼房間名稱？\n");
+    if (strlen(arg) > 10)
+        return notify_fail("房間名稱最長為十個字元(五個中文字)。\n");
+
+    this_object()->set("short", arg);
+    this_object()->save();
+
+    tell_object(me, "ok.\n");
+
+    return 1;
+}
+
+int do_set_long(string arg)
+{
+    object me;
+    me = this_player();
+
+    if (!arg)
+        return notify_fail("你要設什麼房間名稱？\n");
+    if (strlen(arg) > 100)
+        return notify_fail("房間敘述最長為一百個字元(五十個中文字)。\n");
+
+    this_object()->set("long", arg);
+    this_object()->save();
+
+    tell_object(me, "ok.\n");
+
+    return 1;
+}
+
+// for well
+int do_drink(string arg)
+{
+    int old_time, cd_time;
+    object me;
+
+    me = this_player();
+    cd_time = 3600;
+    old_time = this_object()->query("_IS_WELL_TIME_");
+
+    if (old_time)
+    {
+        int diff, m, s;
+        diff = time() - old_time;
+        if (diff < cd_time)
+        {
+            m = (cd_time - diff) / 60;
+            s = (cd_time - diff) % 60;
+            tell_object(me, "還要經過 " + chinese_number(m) + "分" + chinese_number(s) + "秒 水井的水才會再產生。\n");
+            return 1;
+        }
+    }
+
+    // 回滿狀態
+    me->heal_stat("ap", me->query_stat_maximum("ap"));
+    me->heal_stat("hp", me->query_stat_maximum("hp"));
+    me->heal_stat("mp", me->query_stat_maximum("mp"));
+    message_vision(HIW "$N從水井裡舀起一大桶的水，瘋狂的往嘴裡灌，肚子都漲得凸出來了，瞬間把水喝光了！\n" NOR, me);
+    tell_object(me, HIY "(你的狀態完全恢復了！)\n" NOR);
+
+    this_object()->set("_IS_WELL_TIME_", time());
+    this_object()->save();
+
+    return 1;
+}
diff --git a/world/.gitignore b/world/.gitignore
new file mode 100644
index 00000000..5761abcf
--- /dev/null
+++ b/world/.gitignore
@@ -0,0 +1 @@
+*.o
diff --git a/world/world.c b/world/world.c
new file mode 100644
index 00000000..fcea69c1
--- /dev/null
+++ b/world/world.c
@@ -0,0 +1,11 @@
+// write by -Acme-
+
+inherit AREA;
+
+void create()
+{
+    set("name", "天上人間");
+    set("x_axis_size", 49);            // 橫向大小
+    set("y_axis_size", 49);            // 縱向大小
+    setup();
+}

# commandd - 命令管理守护进程

## 功能概述

commandd守护进程负责管理游戏命令系统，提供命令搜索、路径管理和命令别名处理功能。支持动态加载命令目录并维护命令缓存。

## 核心数据结构

### 命令搜索映射表
```lpc
mapping search = ([]);
```

存储格式：`search[命令路径] = ([命令名: 命令文件路径])`

## 接口函数

### rehash
```lpc
void rehash(string dir)
```
重新扫描指定目录的命令文件，更新命令缓存。

**支持的目录：**
- `/cmds/` - 游戏命令目录
- `/mudcore/cmds/` - 核心框架命令目录

**处理流程：**
1. 验证目录路径的合法性
2. 扫描目录中的所有 `.c` 文件作为命令
3. 扫描目录中的所有 `.alias` 文件作为命令别名
4. 更新命令搜索映射表

**别名文件格式：**
- 文件扩展名：`.alias`
- 内容格式：第一行指定目标命令文件名（不含.c扩展名）

### find_command
```lpc
string find_command(string verb, string *path)
```
在指定的命令路径中查找命令文件。

**参数：**
- `verb`：命令名称
- `path`：命令搜索路径数组

**返回值：**
- 找到命令：返回完整的命令文件路径
- 未找到命令：返回0

**搜索顺序：**
按照路径数组的顺序依次查找，找到第一个匹配即返回。

## 工作流程

### 命令加载流程
1. **路径验证** - 确保目录是合法的命令目录
2. **文件扫描** - 获取目录中的所有文件列表
3. **命令识别** - 识别 `.c` 文件作为命令
4. **别名处理** - 识别 `.alias` 文件并解析别名映射
5. **缓存更新** - 更新命令搜索映射表

### 命令查找流程
1. **路径遍历** - 依次检查每个命令路径
2. **缓存检查** - 检查该路径的命令缓存是否存在
3. **缓存重建** - 如果缓存不存在，调用rehash重建
4. **命令匹配** - 在缓存中查找指定命令
5. **结果返回** - 返回找到的命令文件路径

## 命令别名系统

### 别名文件示例
```
# 文件：look.alias
look.c
```

这表示`look.alias`对应`look.c`命令文件，玩家可以通过别名来执行命令。

## 使用示例

```lpc
// 重新扫描命令目录
commandd->rehash("/cmds/usr/");

// 查找命令
string cmd_path = commandd->find_command("look", ({"/cmds/usr/", "/cmds/wiz/"}));
if (cmd_path) {
    write("找到命令：" + cmd_path + "\n");
} else {
    write("未找到命令\n");
}
```

## 技术特点

- **动态加载** - 支持运行时重新扫描命令目录
- **缓存机制** - 维护命令缓存，提高查找效率
- **别名支持** - 支持命令别名，增强用户体验
- **路径灵活** - 支持多路径搜索，便于命令分类管理
- **错误处理** - 完善的错误检测和日志记录

## 相关文件

### 命令目录结构
```
/cmds/
├── usr/        # 普通用户命令
├── wiz/        # 巫师命令
├── imm/        # 天神命令
├── arch/       # 大天神命令
└── adm/        # 管理员命令
```

### 别名文件示例
```
# 如：l.alias
look.c

# 如：i.alias
inventory.c

# 如：eq.alias
equip.c
```

这个系统为MUD游戏提供了灵活的命令管理机制，支持命令的动态加载和别名映射，使得命令系统易于维护和扩展。','content':'# commandd - 命令管理守护进程

## 功能概述

commandd守护进程负责管理游戏命令系统，提供命令搜索、路径管理和命令别名处理功能。支持动态加载命令目录并维护命令缓存。

## 核心数据结构

### 命令搜索映射表
```lpc
mapping search = ([]);
```

存储格式：`search[命令路径] = ([命令名: 命令文件路径])`

## 接口函数

### rehash
```lpc
void rehash(string dir)
```
重新扫描指定目录的命令文件，更新命令缓存。

**支持的目录：**
- `/cmds/` - 游戏命令目录
- `/mudcore/cmds/` - 核心框架命令目录

**处理流程：**
1. 验证目录路径的合法性
2. 扫描目录中的所有 `.c` 文件作为命令
3. 扫描目录中的所有 `.alias` 文件作为命令别名
4. 更新命令搜索映射表

**别名文件格式：**
- 文件扩展名：`.alias`
- 内容格式：第一行指定目标命令文件名（不含.c扩展名）

### find_command
```lpc
string find_command(string verb, string *path)
```
在指定的命令路径中查找命令文件。

**参数：**
- `verb`：命令名称
- `path`：命令搜索路径数组

**返回值：**
- 找到命令：返回完整的命令文件路径
- 未找到命令：返回0

**搜索顺序：**
按照路径数组的顺序依次查找，找到第一个匹配即返回。

## 工作流程

### 命令加载流程
1. **路径验证** - 确保目录是合法的命令目录
2. **文件扫描** - 获取目录中的所有文件列表
3. **命令识别** - 识别 `.c` 文件作为命令
4. **别名处理** - 识别 `.alias` 文件并解析别名映射
5. **缓存更新** - 更新命令搜索映射表

### 命令查找流程
1. **路径遍历** - 依次检查每个命令路径
2. **缓存检查** - 检查该路径的命令缓存是否存在
3. **缓存重建** - 如果缓存不存在，调用rehash重建
4. **命令匹配** - 在缓存中查找指定命令
5. **结果返回** - 返回找到的命令文件路径

## 命令别名系统

### 别名文件示例
```
# 文件：look.alias
look.c
```

这表示`look.alias`对应`look.c`命令文件，玩家可以通过别名来执行命令。

## 使用示例

```lpc
// 重新扫描命令目录
commandd->rehash("/cmds/usr/");

// 查找命令
string cmd_path = commandd->find_command("look", ({"/cmds/usr/", "/cmds/wiz/"}));
if (cmd_path) {
    write("找到命令：" + cmd_path + "\n");
} else {
    write("未找到命令\n");
}
```

## 技术特点

- **动态加载** - 支持运行时重新扫描命令目录
- **缓存机制** - 维护命令缓存，提高查找效率
- **别名支持** - 支持命令别名，增强用户体验
- **路径灵活** - 支持多路径搜索，便于命令分类管理
- **错误处理** - 完善的错误检测和日志记录

## 相关文件

### 命令目录结构
```
/cmds/
├── usr/        # 普通用户命令
├── wiz/        # 巫师命令
├── imm/        # 天神命令
├── arch/       # 大天神命令
└── adm/        # 管理员命令
```

### 别名文件示例
```
# 如：l.alias
look.c

# 如：i.alias
inventory.c

# 如：eq.alias
equip.c
```

这个系统为MUD游戏提供了灵活的命令管理机制，支持命令的动态加载和别名映射，使得命令系统易于维护和扩展。